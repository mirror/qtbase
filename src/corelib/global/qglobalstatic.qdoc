/****************************************************************************
**
** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info\nokia.com)
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** GNU Free Documentation License
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file.
**
** Other Usage
** Alternatively, this file may be used in accordance with the terms
** and conditions contained in a signed written agreement between you
** and Nokia.
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
    \headerfile <QGlobalStatic>
    \title Macro for defining a global static object, also known as a singleton.
    \ingroup tools

    \brief The <QGlobalStatic> header provides the Q_GLOBAL_STATIC macro.
*/

/*!
    \macro Q_GLOBAL_STATIC(ClassName, Identifier)

    This macro makes it easy to use classes as global statics.
    The instance of \a ClassName is created on first use and creation is threadsafe.

    The object is destructed on library unload or application exit.
    Be careful with calling other objects in the destructor of the class
    as you have to be sure that they (or objects they depend on) are not already destructed.

    If you have code that might be called after the global object has been destroyed you can check
    for that using the isDestroyed() function.

    If needed (if the destructor of the global object calls other functions that depend on other
    global statics your destructor has to be called before those global statics
    are destroyed. A Qt post routine does that.) you can also install a post routine (qAddPostRoutine)
    to clean up the object using the destroy() method. If you registered a post routine and the
    object is destroyed because of a lib unload you have to call qRemovePostRoutine!

    Example:
    \code
    class A {
    public:
        ~A();
        ...
    };

    Q_GLOBAL_STATIC(A, globalA)
    // The above creates a new globally static variable named 'globalA' which you
    // can use as a pointer to an instance of A.

    void doSomething()
    {
        // The first time you access globalA a new instance of A will be created automatically.
        A *a = globalA;
        ...
    }

    void removeSomethingFromGlobalA()
    {
        // No need to create globalA if it doesn't exist, just to remove something from it.
        if (globalA.isDestroyed()) {
            return;
        }
        A *a = globalA;
        ...
    }

    void installPostRoutine()
    {
        // A post routine can be used to delete the object when QCoreApplication destructs,
        // not adding such a post routine will delete the object normally at program unload
        qAddPostRoutine(globalA.destroy);
    }

    A::~A()
    {
        // When you install a post routine you have to remove the post routine from the destructor of
        // the class used as global static!
        qRemovePostRoutine(globalA.destroy);
    }
    \endcode

    A common case for the need of deletion on lib unload/app shutdown are Singleton classes. Here's
    an example how to do it:
    \code
    class MySingletonPrivate;
    class EXPORT_MACRO MySingleton
    {
    friend class MySingletonPrivate;
    public:
        static MySingleton *self();
        QString someFunction();

    private:
        MySingleton();
        ~MySingleton();
    };
    \endcode
    in the .cpp file:
    \code
    // This class will be instantiated and referenced as a singleton in this example
    class MySingletonPrivate
    {
    public:
        QString foo;
        MySingleton instance;
    };

    Q_GLOBAL_STATIC(MySingletonPrivate, mySingletonPrivate)

    MySingleton *MySingleton::self()
    {
        // returns the singleton; automatically creates a new instance if that has not happened yet.
        return &mySingletonPrivate->instance;
    }
    QString MySingleton::someFunction()
    {
        // Refencing the singleton directly is possible for your convenience
        return mySingletonPrivate->foo;
    }
    \endcode

    Instead of the above you can use also the following pattern (ignore the name of the namespace):
    \code
    namespace MySingleton
    {
        EXPORT_MACRO QString someFunction();
    }
    \endcode
    in the .cpp file:
    \code
    class MySingletonPrivate
    {
    public:
        QString foo;
    };

    Q_GLOBAL_STATIC(MySingletonPrivate, mySingletonPrivate)

    QString MySingleton::someFunction()
    {
        return mySingletonPrivate->foo;
    }
    \endcode

    Now code that wants to call someFunction() doesn't have to do
    \code
    MySingleton::self()->someFunction();
    \endcode
    anymore but instead:
    \code
    MySingleton::someFunction();
*/

/*!
    \macro Q_GLOBAL_STATIC_WITH_ARGS(ClassName, Identifier, ConstructorArguments)

    Same as Q_GLOBAL_STATIC, but provide \a ConstructorArguments to the constructor of
    \a ClassName when \a Identifier is used the very first time.

    Example:
    \code
    class A
    {
    public:
        A(const char *s, int i);
        ...
    };

    Q_GLOBAL_STATIC_WITH_ARGS(A, globalA, ("foo", 0))
    // The above creates a new globally static variable named 'globalA' which you
    // can use as a pointer to an instance of A.

    void doSomething()
    {
        //  The first time you access globalA a new instance of A will be created automatically.
        A *a = globalA;
        ...
    }
    \endcode
*/
